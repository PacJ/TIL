# 프로토타입

* 자바스크립트는 프로토타입 기반의 객체지향 언어이다.
* 자바스크립트를 이루고 있는 거의 모든것이 객체이다.(원시타입을 제외한것들)



### 객체지향 프로그래밍(Object Oriented Programming)

* 프로그램을 여러개의 독립적 단위(객체)들의 집합으로 표현하려는 프로그래밍 패러다임.
* 다양한 속성중에 프로그램에 필요한 것들만 간추려 내어 표현하는 것을 추상화(abstraction)이라고 한다.
  * 필요한 property들만으로 객체를 표현한것.

* 객체 지향 프로그래밍은 객체의 상태(state)를 나타내는 데이터와(프로퍼티) 데이터를 조작할 수 있는 동작(behavior)을 하나의 논리적 단위로 묶어 생각한다.
*  **상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료 구조를 객체(object)라 한다.** 



### 상속과 프로토타입

* **상속:** 객체지향 프로그래밍의 핵심 개념, 어떠한 객체의 프로퍼티/메소드를 다른 객체가 상속받아 그대로 사용할 수 있는것.

* 자바스크립트는 프로토타입을 기반으로 상속을해 불필요한 중복을 제거한다.

  * ex: new 함수로 여러 객체를 만들때, 중복되는 메소드가 있을때 메소드 하나만 만들어 모든 객체가 공유하는게 이상적이지만, 객체를 만들때마다 메소드를 생성하고 모든 인스턴스가 중복 소유한다.
  * 모든 인스턴스가 동일한 메소드를 중복 소유하는것은 메모리를 불필요하게 낭비한다.
  * 퍼포먼스에도 악영향을 준다.

  ```
  // Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토타입에 추가한다.
  // 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.
  Circle.prototype.getArea = function () {
    return Math.PI * Math.pow(this.radius, 2);
  };
  
  // 인스턴스 생성
  const circle1 = new Circle(1);
  const circle2 = new Circle(2);
  
  // Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는
  // 프로토타입 Circle.prototype로부터 getArea 메소드를 상속받는다.
  // 즉, Circle 생성자
  console.log(circle1.getArea === circle2.getArea); // true
  ```

  * Circle 생성자 함수가 생성만 모든 인스턴스는 자신의 프로토타입인 상위 객체 Circle.prototype의 모든 프로퍼티와 메소드를 상속 받는다.

   ![img](https://poiemaweb.com/assets/fs-images/18-2.png) 

### 프로토타입 객체

* 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다.

* 모든 객체는 생성될때 [[Prototype]] 값으로 프로토타입의 참조를 저장한다.

  * 상위 객체의 프로퍼티를 자신의 것처럼 자유롭게 사용.

* 모든 객체는 프로토타입을 갖는다. 프로토타입은 null이거나 객체다.

* 모든 프로토타입은 생성자 함수와 연결되어 있다.

  * 객체, 프로토타입, 생성자 함수는 서로 연결되어 있다.

   ![img](https://poiemaweb.com/assets/fs-images/18-3.png) 

* _ _proto__ 접근자 프로퍼티로 자신의 [[Prototype]]내부 슬롯이 가리키는 객체에 접근할 수 있다.
* 생성자 함수는 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.



#### _ _proto__ 접근자 프로퍼티

* **모든 객체는 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있다** 

* 내부 슬롯은 직접 접근할수 없어, _ _proto__ 접근자 프로퍼티로 간접적으로 내부 슬롯인 [[Prototype]]의 값에 접근할 수 있다.

* _ _proto__는 접근자 함수(getter/setter)로 [[Prototype]] 내부 슬롯의 값을 얻거나 할당한다.

  * proto로 접근하면 내부에있는 getter 함수인 get _ _proto__가 호출된다.

  * proto 접근자 프로퍼티로 새로운 프로토타입을 할당하면 setter함수 set_ _proto__가 호출된다.

  * > 내부 메소드 [[GetPrototypeOf]]와 [[SetPrototypeOf]]
    >
    > get __proto__은 [[GetPrototypeOf]] 내부 메소드를 호출하여 자신의 프로토타입을 취득하고, set __proto__은 [[SetPrototypeOf]] 내부 메소드를 호출하여 새로운 프로토타입을 할당한다.

* _ _proto__ 접근자 프로퍼티는 상속을 통해 사용된다.
  *  갹체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티이다. 
  *  모든 객체는 상속을 통해 Object.prototype._ _proto__ 접근자 프로퍼티를 사용할 수 있다. 

* 프로토타입[[Prototype]]에 접근하기 위해 접근자 프로퍼티를 사용하는 이유: 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해.
  * 프로토타입 체인은 단방향이어야하는데 서로 참조하면 무한 루프에 빠질수 있다.
* 모든 객체가 _ _proto__를 사용할 수 있는 것은 아니여서 코드 내에서 사용하지 말자.
  * 프로토타입의 참조를 취득할 경우에 _ _proto__대신에
    * Object.getPrototypeOf(method)
  * 프로토타입을 교체하는 경우에는
    * Object.setPrototypeOf(method)를 사용하자.



#### 함수 객체의 prototype 프로퍼티

* **함수 객체는 _ _proto__ 이외에 prototype 프로퍼티도 소유한다.**

* **함수 객체의 prototype 프로퍼티는 생성자 함수가 만들 인스턴스의 프로토타입을 가리킨다.**

  * prototype 프로퍼티는 함수 객체만이 소유한다. 일반 객체는 없다.
  * 생성자 함수가 아닌 함수(non-constructor)는 prototype property를 소유하지 않는다.

*  모든 객체가 가지고있는_ _proto__ 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 동일한 프로토타입을 가리킨다

  * 하지만 프로퍼티를 사용하는 주체가 다르다.

  * _ _proto__ 접근자 프로퍼티는 모든 객체가 상속을 위해 자신의 프로토타입에 접근하기 위해 사용한다.
  * prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 할당하기 위해 사용한다.



#### 프로토타입의 constructor 프로퍼티와 생성자 함수

* 모든 프로토타입은 constructor 프로퍼티를 갖는다.
  * prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.
  * 생성자 함수(함수 객체)가 생성될때 연결된다.



#### 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

* 생성자 함수로 생성된 인스턴스는 프로토타입의 constructor 프로퍼티로 생성자 함수와 연결된다.

* 리터럴 표기법으로 생성된 객체도 프로토타입이 존재하지만, 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 무조건 객체를 생성한 생성자  함수가 아니다.

* Object 생성자 함수는 new 연산자와 함께 호출하지 않아도 new 연산자와 함께 호출한 것과 동일하게 동작한다. 

  * 인수가 전달되지 않았을 때 추상 연산 ObjectCreate을 호출하여 빈 객체를 생성한다. 인수가 전달된 경우에는 인수를 객체로 변환한다.

    ```
    let obj = new Object();
    console.log(obj); // {}
    
    obj = Object();
    console.log(obj); // {}
    ```

  * 객체 리터럴이 평가될 떄는  ObjectCreate을 호출하여 빈객체를 생성하고 프로퍼티를 추가한다.

* 리터럴로 생성된 객체도 상속을 위해 프로토타입이 필요하다.

  * 가상적인 함수를 갖는다: 프로토타입은 생성자 함수와 더불어 생성되어 prototype, constructor 프로퍼티에 의해 연결이 되어있다.
  * 둘이 쌍으로 존재하고, 단독으로 존재할 수 없다.

* | 객체 리터럴        | Object   | Object.protptype   |
  | ------------------ | -------- | ------------------ |
  | 함수 리터럴        | Function | Function.prototype |
  | 배열 리터럴        | Array    | Array.prototype    |
  | 정규 표현식 리터럴 | RegExp   | RegExp.protptype   |



### 프로토타입의 생성 시점

*  객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결되어 있다. 
*  생성자 함수는 사용자가 직접 정의한 생성자 함수와 자바스크립트의 빌트인 생성자 함수로 구분할 수 있다. 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다. 



#### 사용자 정의 생성자 함수와 프로토타입 생성 시점

