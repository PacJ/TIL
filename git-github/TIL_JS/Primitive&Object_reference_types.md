# 원시값, 객체 값 비교

원시(primitive type)의값은 immutable value(변경 불가능).

- 원시 값 할당시 변수에 실제 값이 저장된다.
- 원시 값의 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달(Pass by value)

객체(object/reference type)의 값은 참조타입, mutable(변경 가능)값.

- 객체를 변수에 할당하면 참조 값이 저장된다.
- 객체 값의 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달(Pass by reference)

변수는 상수 사용하듯이 한번 할당하고 사용하고 버리는것이 가장 심플하다.

SCOPE: 식별자의 생명주기(Life Cycle) 변수 생명주기를 최대한 짧게하기위해 SCOPE를 짧게만드는것이 좋다. 함수, 객체 등 짧게 사용하자. 전역변수는 생명주기가 무한이므로 사용하지 않는것이 좋다.

var를 사용하면 전역변수를 난발하게될 가능성이 높다.



## 원시 값(Primitive value)

#### 변경 불가능한 값

- 원시 타입은 immutable value다(변경불가능).
- 재할당을 할수는 있지만, 원레 있던 공간을 수정할수 없고 새로운 공간을 확보해야한다.
- 변수는 재할당으로 값을 변경시킬수 있지만 상수는 단 한번만 할당이 허용된다.
- 이러한 특징을 불변성(immutability)라 한다.



#### 문자열과 불변성(immutability)

- JavaScript의 문자열은 원시타입이며 immutable.



#### 값에 의한 전달(Pass by value)

- 원시타입 값의 변수는 다른 변수에게 할당할때 값을 카피하여 전달한다.
- 별개의 공간에 저장되므로 하나의 변수의 값을 변경하더라도 다른 곳에 영향을 주지 않는다.

![img](https://poiemaweb.com/assets/fs-images/10-3.png)



## 객체

- 객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가/삭제할 수 있다
- 프로퍼티 값에도 제약이 없어, 원시값처럼 확보해야할 메모리 크기를 사전에 정할 수가 없다.
- 따라서 참조 값을 변경하고 사용한다.



#### 변경 가능한 값

- 객체(참조) 타입의 값은 mutable value(변경 가능한 값)이다.
- 객체를 할당한 변수는 참조 값(Reference value)를 값으로 갖는다.
  - 참조 값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체.

![img](https://poiemaweb.com/assets/fs-images/10-6.png)

- 변수 식별자를 참조할때, 식별자는 객체와 연결된 공간의 값들을 참조한다.

- 원시 값은 메모리 주소에 있는 값을 찾아가지만, 객체 값은 메모리 주소에 참조 할수있는 또 다른 메모리 주소에 있는 값들을 참조한다.

- 객체는 값을 바꿀때, 새로운 공간을 만들어서 사용하지 않고, 기존에 있던 공간에서 값을 변경한다.

- 객체를 재할당 하면, 새로운 공간이 식별자를 가지고, 새로운 객체공간을 참조한다.

  - var o = {};

    o = {}; // 객체 재할당.

- 객체를 사용하면 값의 변경 추적이 어려워진다.

  - react는 값의 변경을 추적하기위해 객체를 윈시값으로 사용한다(불변객체).



#### 참조에 의한 전달

- shallow copy(얕은 복사)와 deep copy(깊은 복사)

  ```
  var o = {};
  var c = 0;
  ```

  - 얕은 복사: 참조 값을 copy한다. 두개의 식별자가 같은 값을 공유한다.
    - 값이 바뀌면 식별자 둘다 영향을 받는다.

  - **여러개의 식별자가 하나의 객체를 공유한다.**
  - 깊은 복사: 참조 값을 복사하고 객체에 중첩되어있는 객체까지 모두 복사하고 원시값처럼 완전한 복사본을 만든다.

- 원시값에 동등비교자는 값 자체 내용이 같은지 비교하지만, 객체 값은 값과 주소(참조값)가 일치하지 않으면 False가 나온다.

```
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
};

console.log(person1 === person2); // True

console.log(person1.name === person2.name); // False
```

- 1번은 객체값 비교로 참조 값(위치)가 다르다면 동일하지 않다.
- 2번은 객체 내부에 원시값 비교로 값이 같은 동일하다.



