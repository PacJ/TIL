# 원시값, 객체 값 비교

원시(primitive type)의값은 immutable value(변경 불가능).

- 원시 값 할당시 변수에 실제 값이 저장된다.
- 원시 값의 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달(Pass by value)
- 브라우저 제조사의 구현에 따라 다를 수 있다.

객체(object/reference type)의 값은 참조타입, mutable(변경 가능)값.

- 객체를 변수에 할당하면 참조 값이 저장된다.
- 객체 값의 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달(Pass by reference)

변수는 상수 사용하듯이 한번 할당하고 사용하고 버리는것이 가장 심플하다.

SCOPE: 식별자의 생명주기(Life Cycle) 변수 생명주기를 최대한 짧게하기위해 SCOPE를 짧게만드는것이 좋다. 함수, 객체 등 짧게 사용하자. 전역변수는 생명주기가 무한이므로 사용하지 않는것이 좋다.

var를 사용하면 전역변수를 난발하게될 가능성이 높다.



## 원시 값(Primitive value)

#### 변경 불가능한 값

- 원시 타입은 **immutable value**다(변경불가능).
- 재할당을 할수는 있지만, 원레 있던 공간을 수정할수 없고 새로운 공간을 확보해서 식별자와 연결하고 값을 할당한다.
- 변수는 재할당으로 값을 변경시킬수 있지만 상수는 단 한번만 할당이 허용된다.
- 이러한 특징을 불변성(immutability)라 한다.



#### 문자열과 불변성(immutability)

- JavaScript은 원시타입인 문자열은 제공하며 immutable이다.

  > **유사 배열 객체(Array-like Object)**
  >
  > 유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 배열처럼 각 문자에 접근할 수도 있으며 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수도 있다.



#### 값에 의한 전달(Pass by value)

- 원시타입 값의 변수는 다른 변수에게 할당할때 값을 카피하여 전달한다.
- 별개의 공간에 저장되므로 하나의 변수의 값을 변경하더라도 다른 곳에 영향을 주지 않는다.

![img](https://poiemaweb.com/assets/fs-images/10-3.png)



## 객체

- 객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가/삭제할 수 있다
- 프로퍼티 값에도 제약이 없어, 원시값처럼 확보해야할 메모리 크기를 사전에 정할 수가 없다.
- 따라서 참조 값을 변경하고 사용한다.
- Java같은 클래스 기반 객체 지향 언어는 사전에 정의된 클래스를 기반으로 객체(인스턴스)를 생성한다.
  - 객체를 생성하기 전에 이미 Property와 Method가 정해져 있고 그대로 객체를 생성한다.
  - 객체 생성후에 프로퍼티를 삭제하거나 추가할 수 없다
  - JavaScript는 클래스 없이 객체를 생성할 수 있으며 생성 후에도 동적으로 Property와 Method를 추가할 수 있다.
  - 이론적으로는 비용이 더 많이 드는 비효율적인 방식이여서, V8 JavaScript 엔진은 히든클래스(hidden class)방식을 사용한다. 히든클래스는 Java와 같이 고정된 객체 레이아웃(클래스)과 유사하게 동작한다.



#### 변경 가능한 값

- 객체(참조) 타입의 값은 mutable value(변경 가능한 값)이다.
- 객체를 할당한 변수는 참조 값(Reference value)을 값으로 갖는다.
  - 참조 값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체.

![img](https://poiemaweb.com/assets/fs-images/10-6.png)

- 변수 식별자를 참조할때, 식별자는 객체와 연결된 공간의 값들을 참조한다.

- 원시 값은 메모리 주소에 있는 값을 찾아가지만, 객체 값은 메모리 주소에 참조 할수있는 또 다른 메모리 주소(참조값)에 있는 값들을 찾아가 참조한다.

- 객체는 값을 바꿀때, 새로운 공간을 만들어서 사용하지 않고, 기존에 있던 공간에서 값을 변경한다. 참조 값(주소)은 바뀌지 않는다.

- 객체를 재할당 하면, 새로운 공간이 식별자를 가지고, 새로운 객체공간을 참조한다.

  ```
  var o = {};
  
  o = {}; // 객체 재할당.
  ```

- 객체를 사용하면 값의 변경 추적이 어려워진다.

  - react는 값의 변경을 추적하기위해 객체를 윈시값으로 사용한다(불변객체).



#### 참조에 의한 전달

- shallow copy(얕은 복사)와 deep copy(깊은 복사)

  ```
  var o = {};
  var c = o;
  ```

  - 얕은 복사: 참조 값을 copy한다. 두개의 식별자가 같은 값을 공유한다.
    - 값이 바뀌면 식별자 둘다 영향을 받는다.
  - **여러개의 식별자가 하나의 객체를 공유한다.**

  - 깊은 복사: 참조 값을 복사하고 객체에 중첩되어있는 객체까지 모두 복사하고 원시값처럼 완전한 복사본을 만든다.

- 원시값에 동등비교자는 값 자체 내용이 같은지 비교하지만, 객체 값은 값과 주소(참조값)가 일치하지 않으면 False가 나온다.

```
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
};

console.log(person1 === person2); // False

console.log(person1.name === person2.name); // True
```

- 1번은 객체값 비교로 참조 값(위치)가 다르다면 동일하지 않다.
- 2번은 객체 내부에 원시값 비교로 값이 같은 동일하다.



