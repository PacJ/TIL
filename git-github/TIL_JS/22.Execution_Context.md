# 실행 컨텍스트

* 자바스크립트는 문맥을 보고 동작한다.
* 자바스크립트의 식별자를 등록하고 값을 할당하면 둘다 실행 컨텍스트에 등록된다.
* 스코프를 기반으로 식별자와 바인딩된 값을 관리하는 방식, 호이스팅이 발생하는 이유다.

* 자바스크립트 엔진이 관리하는 객체들이다.



## 실행 가능한 코드

* ECMAScript 사양은 실행 가능한 코드(Executable Code)를 4가지 유형으로 구분한다.

* 실행 컨텍스트를 만드는 방식이 다른 코드들에 따라 구분한다.

  | 실행 가능한 코드         | 설명                                                         |
  | :----------------------- | :----------------------------------------------------------- |
  | 전역 코드(Global code)   | 전역에 존재하는 텍스트 코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
  | 함수 코드(Function code) | 함수 내부에 존재하는 텍스트 코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
  | eval 코드(Eval code)     | 빌트인 전역 함수인 eval 함수에 인수로 전달된 텍스트 코드를 말한다. |
  | 모듈 코드(Module code)   | 모듈 내부에 존재하는 텍스트 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다. |

  * eval, with는 사용하지 말자.

* 자바스크립트는 파일 스코프를 지원하지 않아서 여러개의 파일이 전역 하나를 공유한다.

  * 모듈 개념을 지원하지 않는것이다.
  * 인위적으로 파일 스코프를 만들어야한다.

 ![img](https://poiemaweb.com/assets/fs-images/22-1.png) 



## 실행 가능한 코드의 평가와 실행

* 코드가 실행 되기 이전에 코드가 평가되고 실행된다.
* 코드들을 평가하는 과정에 실행 컨텍스트가 생성되고 선언문들이 평가되어 결과가 실행 컨텍스트에 등록된다.
  * 코드를 평가하면서 식별자 내부에 undefined가 할당된다.
* 코드의 평가가 끝나면 선언문을 제외한 코드가 순차적으로 실행된다. 
  * 코드 실행에 필요한 정보를 실행 컨텍스트에서 가져오고 실행한다.
* 코드 실행의 실행 결과를 실행 컨텍스트에서 관리한다.

 ![img](https://poiemaweb.com/assets/fs-images/22-2.png) 



## 실행 컨텍스트의 역할

* var 로 선언한 변수는 변수 선언과 함께 undefined값을 준다.

* let이나 const는 선언단계와 초기화 단계가 분리되어있다.

  * 코드의 평가 단계에 선언만 하고 초기화를 하지 않는다.
    * (uninitialized)

* 함수는 평가단계에서 할당까지 이루어진다.

  * 함수 객체가 할당된다.
  * 전역코드 평가에서 함수 내부는 보지 않는다.

* 평가 단계가 끝나고 초기화를 한다.

  * 변수들에 값을 할당한다.

* console은 전역 객체의 프로퍼티이고, log프로퍼티는 console 프로토타입의 인스턴스 메소드다.

  **실행 컨텍스트가 필요한 이유:**

  1. 선언으로 생성된 모든 식별자를 스코프를 구분해 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 한다.
  2. 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 스코프 체인을 통해 상위스코프로 이동하며 식별자를 검색할 수 있어야 한다.
  3. 현재 실행 중인 코드의 실행 순서를 변경(ex: 함수 호출에 의한 실행 순서 변경)할 수 있어야 되고 다시 되돌아갈 수도 있어야 한다.

* **실행 컨텍스트(Execution Context)는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.** 

*  실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 실행 순서 관리를 구현한 내부 매커니즘이다.



## 실행 컨텍스트 스택

* 코드를 평가 하면 실행 컨텍스트가 생성되고, 실행 컨텍스트들은 서로 쌓여있는 구조로 관리된다.

  * 스택 자료 구조로 관리된다.

* **실행 컨텍스트 스택은 코드의 실행 순서를 관리한다.**

* 스택의 최상위에 있는 실행 컨텍스트가 현재 실행되고 있는 코드다.

  * 실행 중인 실행 컨텍스트(running execution context)라 부른다.

* 실행이 종료되면 스택에서 빠지고 다음 실행 컨텍스트가 실행된다.

* 스택을 통해 실행이 종료되면 다시 돌아갈 실행 컨텍스트를 찾을 수 있다.

  ```
  const x = 1;
  
  function foo () {
    const y = 2;
  
    function bar () {
      const z = 3;
      console.log(x + y + z);
    }
    bar();
  }
  
  foo(); // 6
  ```

1. 전역 코드가 실행되면 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 푸시된다.

   * 전역 변수와 함수가 전역 실행 컨텍스트가 등록된다.

   

2. foo 함수 코드를 평가하고 실행한다.

   * 전역 코드의 실행이 일시 중단되고 코드의 제어권이 foo함수 내부로 이동한다.
   * foo 함수 내부 함수 코드를 평가해 foo 함수 실행 컨텍스트를 생성하고, 실행 컨텍스트 스택에 푸시한다.
   * 지역 변수 y와 중첩 함수 bar가 foo 함수 실행 컨텍스트에 등록된다.
   * foo 함수 코드가 실행되고, y에 값이 할당되고 중첩 함수 bar가 호출된다.

   

3. bar 함수 코드를 평가하고 실행한다.

   * 중첩 함수 bar가 호출되면 함수 foo의 코드 실행이 일시 중단, 제어권이 bar함수 내부로 이동한다.
   * 내부의 함수 코드를 평가하고 bar 함수 실행 컨텍스트를 생성하고 스택에 푸시한다.
   * 지역 변수 z가 bar 함수 실행컨텍스트에 등록, 함수가 실행되면서 z에 값이 할당되고 console.log 메소드 호출 이후 함수 bar는 종료된다.

   

4. bar의 실행이 종료 되면 코드의 제어권이 스택에 따라 다시 함수 foo로 이동.

   * 자바스크립트 엔진은 bar 함수 실행 컨텍스트를 스택에서 pop해 제거한다.
   * foo에 더이상 실행할 코드가 없어 종료된다.

   

5. 전역 코드로 복귀한다.

   * 함수 foo가 종료되고,  foo 함수 실행 컨텍스트를 스택에서 pop하여 제거하고 코드의 제어권이 다시 전역 코드로 이동한다.
   * 전역에서도 더이상 실행할 코드가 없어, 전역 실행 컨텍스트도 스택에서 pop되어 실행 컨텍스트 스택에 아무것도 남지 않는다.

 ![img](https://poiemaweb.com/assets/fs-images/22-3.png) 

* 실행 컨텍스트 스택으로 현재 실행 코드가 무엇인지, 어디로 돌아가야하는지 관리한다.



## 동기식 처리 모델과 비동기식 처리 모델

* 자바스크립트는 실행 컨텍스트 스택을 하나만 갖는다.(single thread)

  * 여러 개의 실행 컨텍스트 스택에서 실행할 수 없다.
  * 동시에 두가지 태스크를 실행할 수 없다.
  * 최상위 스택만이 실행중이고, 나머지는 대기중이다.

* 하나의 처리가 종료되어야 다음 처리를 실행할 수 있는 것을 **동기식 처리 모델(Synchonous processing model)**이라고 한다.

   ![img](https://poiemaweb.com/assets/fs-images/22-4.png) 

* **자바스크립트는 비동기식 처리 모델(Asynchronous processing model)을 갖는다.**

* 비동기식 처리 모델(Asynchronous processing model)

   ![img](https://poiemaweb.com/assets/fs-images/22-5.png) 

  * 서버로부터 데이터가 응당될 때까지 대기하지 않고(Non-Blocking) 즉시 다음 task를 수행한다.

* 비동기식으로 동작하는 코드는 순차적으로 실행되지 않아 가독성이 좋지 않다.

  * 콜백 헬을 유발한다.
  * call-back hell을 해결하기 위해 Promise가 생겼다.
  * Promise: 성공/실패에 따라 호출하는 함수가 다르다.



## 렉시컬 환경(Lexical Environment)

* 렉시컬 환경(Lexical Environment)은 식별자가 선언되는 환경(렉시컬 스코프)을 말한다. 
  * 렉시컬 환경은 스코프와 식별자를 관리한다.
  * 객체 형태의 스코프를 만들고 이곳에 식별자를 등록한다.
  * 등록된 식별자와 바인딩된 값을 관리한다.
  * 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 한다.
* Lexical Scope: 함수가 정의된 위치에 따라 상위 스코프가 결정된다.
  * 스코프 체인은 렉시컬 환경의 연결이다.

![img](https://poiemaweb.com/assets/fs-images/22-6.png) 

* 실행 컨텍스트 자료구조가 렉시컬 환경으로 이루어져 있다.
  * 실행 컨텍스트는 LexicalEnvironment, VariableEnvironment 컴포넌트들로 구성이 된다.

![img](https://poiemaweb.com/assets/fs-images/22-7.png) 

>  **LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트** 
>
> 실행 컨텍스트가 생성되면 둘다 같이 Lexical Environment를 참조한다. 이후 코드가 실행되다가 특수한 상황을 만나면 VariableEnvironment 컴포넌트가 새로운 렉시컬 환경을 생성하고, 이때부터 두 컴포넌트의 내용이 달라지게 된다. 달라지고 나면 주로 LexicalEnvironment 컴포넌트를 사용한다.

* Lexical Environment는 3가지 component로 구성된다.

   ![img](https://poiemaweb.com/assets/fs-images/22-8.png) 

  * EnvironmentRecord(환경 레코드)에는 스코프에 포함된 식별자가 있다.
  * 외부 렉시컬 환경 참조(OuterLexicalEnvironmentReference)는 외부 렉시컬 환경을 가리키는 참조를 저장한다. 외부 렉시컬 환경: 해당 실행 컨텍스트를 생성한 코드의 상위 코드의 렉시컬 환경. 서로 상위 렉시컬 환경을 참조하면서 단방향 링크드 리스트인 스코프 체인을 구현한다.
  * ThisBinding: 렉시컬 환경의 this에 바인딩된 객체를 나타낸다.



## 실행 컨텍스트의 생성과 식별자 검색 과정

```
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
```

#### 전역 객체 생성

* 전역 객체는 전역 코드가 평가되기 이전에 생성된다.
* 전역 프로퍼티와 전역 함수, 표준 빌트인 객체가 추가되고 클라이언트 사이드 Web API 또는 호스트 객체가 추가된다.

#### 전역 코드 평가

![img](https://poiemaweb.com/assets/fs-images/22-10.png) 

1. 전역 실행 컨텍스트를 생성하고 스택에 푸시한다.

2. 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트의 Lexical/VariableEnvironment 컴포넌트를 바인딩한다.
3. 전역 환경 레코드를 생성하고, 객체 환경 레코드(Object Environment Record), 선언적 환경 레코드(Declarative Environment Record)를 생성한다.
   * var로 선언된 모든 전역변수, 함수 선언문으로 정의된 전역 함수는 객체 환경 레코드에 등록되고 관리된다.
     * 객체 환경 레코드는 bindingObject라고 부르는 객체와 연결된다.
     * 객체 환경 레코드에 있는 식별자는 bindingObject의 프로퍼티가 된다.
     * 객체 환경 레코드에서 식별자를 검색하면 bindingObject 의 프로퍼티를 검색하고 반환한다.
     * bindingObject는 전역 객체이므로 등록한 식별자는 전부 전역 객체의 프로퍼티가 된다.
   * let, const로 선언된 전역 변수는 선언적 환경 레코드에 등록되고 관리된다.
     * 선언 단계와 초기화 단계가 분리되어 진행한다.
     * 초기화 단계(할당문의 실행)가 실행되기 이전까지 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지게 된다.
     * let, const로 선언된 전역 변수는 전역 객체의 프로퍼티가 되지 않고 전역 렉시컬 환경의 선언적 환경 레코드에 별도로 관리된다.
4. 외부 렉시컬 환경에 대한 참조를 할당하고, this를 바인딩한다.
   * 외부 렉시컬 환경에 대한 참조는 현재 평가 중인 코드를 포함하는 외부 코드의 렉시컬 환경을 가리킨다.
   * 이를 통해 스코프 체인을 구현한다.



#### 전역 코드 실행

* **식별자를 검색할 때 실행 중인 실행 컨텍스트의 렉시컬 환경에서 검색한다.**

* 할당문들이 실행되면서 값들이 할당된다. ![img](https://poiemaweb.com/assets/fs-images/22-17.png) 



#### foo 함수 코드 평가

```
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
```

 ![img](https://poiemaweb.com/assets/fs-images/22-18.png) 

* 함수 실행 컨텍스트를 생성하고 스택에 푸시한다.
* 함수 렉시컬 환경을 생성한다.
* 함수 환경 레코드를 생성한다.
  * 함수 내에서 선언한 변수와 함수 정의를 등록하고 관리한다.
* 외부 렉시컬 환경에 대한 참조를 할당한다.
*  this 바인딩을 한다.
* 이후 foo 함수 코드를 실행한다.



#### bar 함수 코드 평가

* bar 함수가 호출 되고 함수 내부로 코드 제어권이 이동한다.

#### ![img](https://poiemaweb.com/assets/fs-images/22-24.png) 

* 이후 함수 코드가 실행된다.
  * 매개변수에 인수를 할당하고, 지역 변수 z에 값이 할당된다.
* 코드가 실행되고 나서 더이상 읽을 코드가 없으면, 실행 컨텍스트가 pop되고 다시 전역 실행 컨텍스트가 실행 중인 컨텍스트가 된다.
* 실행 컨텍스트 스택에 쌓여있는 실행 컨텍스트는 실행이 종료되면 없어지지만, 해당 실행 컨텍스트의 렉시컬 환경과 Function Environment Record는 남아있다.
  * 참조 하는 코드가 남아있으면 가비지 콜렉터의 대상이 되지 않는다.
* 실행 컨텍스트가 종료되면, 렉시컬 환경이 종료되고, 함수 환경 레코드도 종료.



## 실행 컨텍스트와 블록 레벨 스코프

* 실행 컨텍스트는 전역코드, 함수코드, eval 코드, 모듈 코드만 만들수 있다.

  ```
  let x = 1;
  
  if (true) {
    let x = 10;
    console.log(x); // 10
  }
  
  console.log(x); // 1
  ```

* if 문이 실행되면 블록 레벨 스코프를 생성해야 한다.
* if문을 위한 블록 레벨 스코프를 생성 하려면 if문을 위한 선언적 환경 레코드(Declarative Environmnet Record)를 갖는 렉시컬 환경을 새롭게 생성해야한다.
* 이 렉시컬 환경이 기존의 전역 렉시컬 환경을 교체한다.
* 외부 렉시컬 환경 참조는 교체되기 이전의 전역 렉시컬 환경을 가리킨다.

![img](https://poiemaweb.com/assets/fs-images/22-29.png) 

* if문 뿐만 아니라 모든 블록문에 적용된다.
* for 문의 경우, 반복 될때마다 새로운 렉시컬 환경을 생성한다.

