# 실행 컨텍스트

* 자바스크립트는 문맥을 보고 동작한다.
* 자바스크립트의 식별자를 등록하고 값을 할당하면 둘다 실행 컨텍스트에 등록된다.
* 스코프를 기반으로 식별자와 바인딩된 값을 관리하는 방식, 호이스팅이 발생하는 이유다.

* 자바스크립트 엔진이 관리하는 객체들이다.



## 실행 가능한 코드

* ECMAScript 사양은 실행 가능한 코드(Executable Code)를 4가지 유형으로 구분한다.

* 실행 컨텍스트를 만드는 방식이 다른 코드들에 따라 구분한다.

  | 실행 가능한 코드         | 설명                                                         |
  | :----------------------- | :----------------------------------------------------------- |
  | 전역 코드(Global code)   | 전역에 존재하는 텍스트 코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
  | 함수 코드(Function code) | 함수 내부에 존재하는 텍스트 코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
  | eval 코드(Eval code)     | 빌트인 전역 함수인 eval 함수에 인수로 전달된 텍스트 코드를 말한다. |
  | 모듈 코드(Module code)   | 모듈 내부에 존재하는 텍스트 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다. |

  * eval, with는 사용하지 말자.

* 자바스크립트는 파일 스코프를 지원하지 않아서 여러개의 파일이 전역 하나를 공유한다.

  * 모듈 개념을 지원하지 않는것이다.
  * 인위적으로 파일 스코프를 만든다.

 ![img](https://poiemaweb.com/assets/fs-images/22-1.png) 



## 실행 가능한 코드의 평가와 실행

* 코드가 실행 되기 이전에 코드가 평가되고 실행된다.
* 코드의 평가는 선언문들을 처리하는 것이다.
* 코드의 평가가 끝나면 식별자가 생기고, 식별자들을 실행 컨텍스트에 등록한다.
* 코드를 평가하면서 식별자 내부에 undefined가 할당된다.
* 코드 실행에 필요한 정보를 실행 컨텍스트에서 받아온다.

 ![img](https://poiemaweb.com/assets/fs-images/22-2.png) 



## 실행 컨텍스트의 역할

* var 로 선언한 변수는 변수 선언과 함께 undefined값을 준다.
* let이나 const는 선언단계와 초기화 단계가 분리되어있다.
  * 코드의 평가 단계에 선언만 하고 초기화를 하지 않는다.
    * (uninitialized)
* 함수는 평가단계에서 할당까지 이루어진다.
  * 함수 객체가 할당된다.
  * 전역코드 평가에서 함수 내부는 보지 않는다.
* 평가 단계가 끝나고 초기화를 한다.
  * 변수들에 값을 할당한다.
* log프로퍼티는 console 프로토타입의 인스턴스 메소드.
*  **실행 컨텍스트(Execution Context)는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.** 
*  실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 실행 순서 관리를 구현한 내부 매커니즘이다.



## 실행 컨텍스트 스택

* 스택에서 맨 위에 있는것이 현재 실행되고 있는 코드다.

* 실행이 종료되면 스택에서 빠지고 다음 것이 실행된다.

* 스택을 통해 실행이 종료되면 돌아갈 곳을 찾을 수 있다.

  ```
  const x = 1;
  
  function foo () {
    const y = 2;
  
    function bar () {
      const z = 3;
      console.log(x + y + z);
    }
    bar();
  }
  
  foo(); // 6
  ```

  * 전역 실행 컨텍스트 들어가고
  * foo 실행 컨텍스트 쌓이고
  * var 실행 컨텍스트 쌓이고
  * var 실행 종료시 foo로 돌아가고, foo실행 종료시 전역으로 돌아간다.

   ![img](https://poiemaweb.com/assets/fs-images/22-3.png) 

* 실행 컨텍스트 스택으로 현재 실행 코드가 무엇인지, 어디로 돌아가야하는지 관리한다.



## 동기식 처리 모델과 비동기식 처리 모델

* 자바스크립트는 실행 컨텍스트 스택을 하나만 갖고(single thread), 비동기식 처리 모델을 갖는다.

  

* 동기식 처리 모델(Synchronous processing model)

   ![img](https://poiemaweb.com/assets/fs-images/22-4.png) 

  * 현재 실행중인 실행컨텍스트만 실행되고 나머지 실행 컨텍스트들은 대기중이다.
  * 블로킹된다.

* 비동기식 처리 모델(Asynchronous processing model)

   ![img](https://poiemaweb.com/assets/fs-images/22-5.png) 

  * 서버로부터 데이터가 응당될 때까지 대기하지 않고(Non-Blocking) 즉시 다음 task를 수행한다.

* call-back hell을 해결하기 위해 Promise가 생겼다.
  * Promise: 성공/실패에 따라 호출하는 함수가 다르다.



## 렉시컬 환경(Lexical Environment)

* 렉시컬 환경(Lexical Environment)은 식별자가 선언되는 환경을 말한다. 
* Lexical Scope: 함수가 정의된 위치에 따라 상위 스코프가 결정된다.
  * 스코프 체인은 렉시컬 환경의 연결이다.

![img](https://poiemaweb.com/assets/fs-images/22-6.png) 

* Lexical Environment: 
  * 실행 컨텍스트 자료구조가 렉시컬 환경으로 이루어져 있다.

![img](https://poiemaweb.com/assets/fs-images/22-7.png) 

>  **LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트** 
>
> 실행 컨텍스트가 생성되면 둘다 같이 Lexical Environment를 참조한다. 이후 코드가 실행되다가 특수한 상황을 만나면 

* Lexical Environment는 3가지 component로 구성된다.

   ![img](https://poiemaweb.com/assets/fs-images/22-8.png) 

  * EnvironmentRecord에는 스코프에 포함된 식별자가 있다.
  * 외부 렉시컬 환경 참조(OuterLexicalEnvironmentReference)는 외부 렉시컬 환경을 가리키는 참조를 저장한다. 외부 렉시컬 환경: 상위 코드의 
  * ThisBinding: 렉시컬 환경의 this에 바인딩된 객체를 나타낸다.



## 실행 컨텍스트의 생성과 식별자 검색 과정

#### 전역 코드의 실행

```
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
```

![img](https://poiemaweb.com/assets/fs-images/22-10.png) 

* 전역 코드가 평가가 끝나면 이렇게 된다.
* 전역 스코프는 상위 스코프가 존재하지 않는다.
  * 따라서 전역 렉시컬스코프의 OuterLexicalEnvironmentReference는 null이다.



#### 전역 코드 실행

* 할당문이 실행되면서 값들이 들어간다. ![img](https://poiemaweb.com/assets/fs-images/22-17.png) 



#### foo 함수 코드 평가

```
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
```

 ![img](https://poiemaweb.com/assets/fs-images/22-18.png) 

* 함수의 식별자를 찾을때 현재 실행중인 실행컨텍스트에서부터 상위로 올라가면서 찾는다. (스코프체인을 실행컨텍스트로 생각하면)
  * 현재 실행중인 실행컨텍스트가 최상위 실행컨텍스트다.
  * 최상위 실행컨텍스트로부터 찾는다.
  * 실행컨텍스트의 Lexical Environment로 들어가 functionEnvironmentRecord로 들어가 식별자가 있는지 확인한다.
  * 식별자가 존재하지 않으면 OuterLexicalEnvironmentReference를 따라 상위 렉시컬 환경으로 이동해 찾는다.



#### bar 함수 코드 평가

####  ![img](https://poiemaweb.com/assets/fs-images/22-24.png) 

* 실행 컨텍스트 스택에 쌓여있는 실행 컨텍스트는 실행이 종료되면 없어지지만, 해당 실행 컨텍스트의 렉시컬 환경과 Function Environment Record는 남아있다.
* 실행 컨텍스트가 종료되면, 렉시컬 환경이 종료되고, 함수 환경 레코드도 종료.



## 실행 컨텍스트와 블록 레벨 스코프

* 실행 컨텍스트는 전역코드, 함수코드, eval 코드, 모듈 코드만 만들수 있다.

  ```
  let x = 1;
  
  if (true) {
    let x = 10;
    console.log(x); // 10
  }
  
  console.log(x); // 1
  ```

  ![img](https://poiemaweb.com/assets/fs-images/22-29.png) 

