## 함수

* 프로그래밍 언어의 함수도 수학의 함수와 같은 개념이다.

  ```
  function add(x, y) {
    return x + y;
  }
  
  add(2, 5); // 7
  ```

* 함수는 일련의 과정을 문들로 구현하고 코드블록으로 감싸서 **하나의 실행 단위**를 정의한것이다.

* 입력을 받아서 출력을 내보내는데, 입력을 받는 변수를 매개변수(parameter), 입력값을 인수(argument), 출력을 반환값(return value)라고 한다.

* 함수는 함수정의(Function Definition)을 통해 생성한다.

  ```
  // 함수 정의
  function add(x, y) {
  	return x + y;
  }
  ```

  * 정의후에 인수를 매개변수로 함수에게 전달해 함수의 실행을지시.

    * 이를 함수 호출(Function call/invoke)이라고 한다.
* 함수 호출문은 변수에 할당해야지 호출한 값을 사용할 수 있다. 함수 호출문은 변수에 할당가능 하므로 표현식이다.
  
    ```
    // 함수 호출
    var result = add(2, 5);
    console.log(result); // 7
    ```



#### 함수의 사용 이유

* 함수는 필요함에 따라서 여러번 호출할수 있다.
* 동일한 작업을 반복적으로 해야한다면 미리 정의된 함수를 재사용하는게 효율적이다. 코드의 재사용이라는 측면에서 매우 유용하다.
* 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높인다.
* 함수도 변수처럼 이름(식별자)를 붙일수있다. 좋은이름의 함수는 코드의 가독성을 향상시킨다.





#### 함수 리터럴(Function Literal)

* 함수도 객체 리터럴처럼 함수 리터럴로 생성할 수 있다.

* 함수 리터럴은 function키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성.

  ![img](https://poiemaweb.com/assets/fs-images/11-2.png)
  * 함수 이름:
    * 함수 이름은 식별자이므로 식별자 네이밍 규칙을 준수해야 한다.
    * 함수 이름은 함수 몸체 내에서만 참조할 수 있다.
    * 함수 이름은 생략할 수 있다. 이름있는 함수를 기명함수(named function), 이름 없는 함수를 익명 함수(anonymous function)이라 한다.
  * 매개변수 목록:
    * 0개 이상의 매개변수를 괄호로 감싸고 쉼표로 구분한다.
    * 매개변수에는 인수가 할당된다.
    * 매개변수는 함수 몸체 내에서 변수와 동일하게 취급한다. 네이밍규칙을 준수하자.
  * 함수 몸체:
    * 함수 호출시 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드블록이다.
    * 함수 몸체는 함수 호출에 의해 실행된다.

* 함수 리터럴은 평가되어 생성된 객체를 변수에 할당한다. **함수는 객체다.**

* 함수는 일반 객체와 호출할수 있다는점과, 일반 객체에는 없는 고유한 프로퍼티가 있는점에서 다르다.



## 함수 정의

* 함수를 정의하는 방법은 4가지가 있다.

  * **함수 선언문(Function Declaration/Function Statement)**

    * 표현식이 아닌 문

    * ```
      function add(x, y) {
        return x + y;
      }
      ```

  * **함수 표현식(Function Expression)**

    * 표현식인 문

    * ```
      var add = function (x, y) {
        return x + y;
      };
      ```

  * **Function 생성자 함수(Function Constructor)**

    * ```
      var add = new Function('x', 'y', 'return x + y');
      ```

  * **화살표 함수(Arrow Function):ES6**

    * ```
      var add = (x, y) => x + y;
      ```

* 함수를 정의한다는 면에서는 동일하지만, 중요한 차이가 있다.

* 변수는 선언(Declaration)하지만 함수는 정의(Define)한다고 표현한다.



#### 함수 선언문

* 리터럴 표기법과 형태가 동일하지만, 함수 선언문은 **함수 이름을 생략할 수 없다.**

* 함수 문(Function Statement)이라고도 부른다. 함수를 정의하는 문이지만 표현식이 아닌 문이다.

* 함수 선언문이 실행되면 함수 객체를 생성하고, 생성된 객체에 할당할 변수가 있어야한다. 함수 객체를 변수에 할당하지 않으면 아무도 참조하지 않게되어 해제된다.

  * 자바스크립트는 함수이름과 **동일한 이름의 식별자를 암묵적으로 선언**하고 함수 객체를 할당한다.

    * 하위버전 호환성을 유지하기 위해서 변수 let, const로 생성하지 않고,  var로 생성해 함수가 전역 객체(window의 객체)가 된다.

  * 식별자는 참조값을(함수가 들어있는 주소를 값) 가진다.

  * ```
    function add(x, y) {
      return x + y;
    } // add라는 변수를 암묵적으로 선언하고 객체를 할당한다.
    ```

* 함수는 함수 이름이 아닌 **함수 객체를 가르키는 변수로 호출**한다. 자바스크립트가 암묵적으로 선언한 함수이름과 동일한 식별자로 호출하는것이다.



#### 함수 표현식

* 자바스크립트의 함수는 **일급객체(first-class object)**로  변수에 할당 할 수도 있고 Property의 값이 될 수도 있으며 배열의 요소가 될 수도 있다.

* 함수가 일급 객체라는것은 **함수를 값처럼 자유롭게 사용할 수 있다**는 것이다.

* 일급객체이기에 리터럴로 생성한 함수 객체는 변수에 할당할 수 있다.

  * 이렇게 리터럴을 변수에 할당하여 함수를 정의하는 방식을 함수 표현식(Function expression)이라 한다.

  * ```
    var add = function (x, y) {
      return x + y;
    };
    
    console.log(add(2, 5)); // 7
    ```

* 함수 리터럴의 함수 이름은 생략할 수 있고, 이러한 함수를 익명 함수(anonymous function)이라 한다.

* 함수 선언문과 같이, 호출할 때 함수 이름이 아닌 함수 객체를 가리키는 변수를 사용해야한다. **함수 이름은 함수 몸체 내부에서만 유효하기 때문이다.**



#### 함수 생성 시점과 함수 호이스팅

* **함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수는 생성시점이 다르다.**
* 모든 선언문과 같이 함수 선언문은 런타임 이전, 구문분석 단계에서 먼저 실행된다.
  * **함수 호이스팅(Function Hoisting)이라 한다.**
* 따라서 선언문 이전에 호출할수 있지만, 함수 표현식은 표현식 이전에 호출 할 수 없다.
* 변수 호이스팅과는 다르게 함수 호이스팅은 선언, 초기화, 할당(암묵적으로 선언된 변수에 함수 객체를 할당)단계가 동시에 진행된다.
* 함수 표현식은 변수 할당문의 값이 함수 리터럴인 문이다, 할당문이 실행되는 런타임에 평가되어 함수 객체가 된다.
  * 표현식 이전에 참조하면 undefined가 반환된다. 함수전에 변수가 선언되므로 변수가 undefined라는 값을 가지고 나중에 객체를 할당한다.
* 함수 호이스팅은 코드의 가독성을 떨어트릴수 있어 함수 표현식을 사용하자.



#### Function 생성자 함수

* 생성자 함수(Constructor Function)

  * 객체를 생성하는 함수를 말한다.

* 기본 빌트인 함수인 Function 생성자 함수는 매개변수 목록, 함수 몸체를 문자열로 전달받는다.

* new 연산자와 함께 호출해 생성된 함수 객체를 반환한다.

  * ```
    var add = new Function('x', 'y', 'return x + y');
    
    console.log(add(2, 5)); // 7
    ```

* 이렇게 함수를 생성하는것은 좋지 않다.
* 함수 선언문/ 함수 표현식으로 생성한 함수와 동일하게 동작하지 않는다.



#### 화살표 함수(Arrow function)

* ES6 새로 도입, function 키워드대신 화살표(=>) 사용.
* 항상 익명 함수(anonymous function)으로 정의한다.
* 모든 상황에 사용할 수는 없다



#### 함수 호출

* 함수를 참조하는 변수, 한쌍의 소괄호인 함수 호출 연산자로 호출한다.
* 함수 호출 연산자 내에는 0개 이상 인수(argument)를 쉼표로 구분하여 나열.
* 인수는 매개변수에 할당할 수 있는 값이어야 한다.
* 함수를 호출하면 실행 흐름을 중단하고 호출된 함수로 컨트롤을 넘긴다.



#### 매개변수와 인수

* 함수 외부에서 내부로 값을 전달할때, 매개변수(parameter)를 통해 인수를 전달한다.

* 인수는 함수를 호출할 때 지정하고 개수, 타입에 제한이 없다.

  ![img](https://poiemaweb.com/assets/fs-images/11-5.png)

* 함수가 호출되면 함수 몸체 내에 암묵적으로 매개변수가 생성되고 변수와 마찬가지로 undefined로 초기화후 인수가 할당된다. 호출될때마다 이 단계들을 거친다.
* 매개변수는 몸체 내부에서만 참조할 수 있다(스코프=함수 내부).
* 매개변수의 개수만큼 인수를 전달하는게 일반적이지만 그렇지 않아도 에러가 발생하지는 않는다. 인수가 부족한 경우 매개변수의 값은 undefined다.
* 인수가 매개변수보다 많을 경우, 초과되는 인수는 무시된다.
  
  * 모든 인수는 암묵적으로 arguments객체의 프로퍼티로 보관된다.



#### 인수 확인

```
function add(x, y) {
  return x + y;
}

console.log(add(2));        // NaN
console.log(add('a', 'b')); // 'ab'

function add(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    throw new TypeError('매개변수에 숫자 타입이 아닌 값이 할당되었습니다.');
  }

  return x + y;
}
console.log(add(2));        // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.
console.log(add('a', 'b')); // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.
```

* 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다
* 자바스크립트 함수는 매개변수의 타입을 사전에 지정하지 않는다.
* 두 인수가 숫자값인지 확인하기위해 타입 확인문을 사용하는데 이는 가독성을 떨어트려서 modern JavaScript에서는 Typescript를 사용한다.



#### 매개변수의 개수

* 매개변수는 순서에 의미가 있으므로(순서에 맞춰 인수를 할당) 많이지면 함수를 호출할때 전달해야할 인수의 순서를 고려해야 한다.
  
  * 함수 사용을 어렵게하고 실수할 가능성을 높인다
  
* 코드에 방해가 되는 요소이므로 0개가 이상적이며 적을수록 좋다.

* 매개변수는 최대 3개 이상을 넘지 말자.

* 여러개가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달받자.

  ```
  $.ajax({
    method: 'POST',
    url: '/user',
    data: { id: 1, name: 'Lee' },
    cache: false
  });
  ```

* 함수 밖에 변수에 할당후에 함수에 넣지 않고, 함수 내에서 객체를 만듬으로 외부에서 접근변경하지 못하게 하였다.

#### 외부 상태의 변경과 함수형 프로그래밍

* 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다.

  * 매개변수도 타입에따라(원시,객체) 값에 의한 전달(Pass by value), 참조에 의한 전달(Pass by reference)방식을 따른다.

* 매개변수에 값을 전달하는 방식을 값에 의한 호출(Call by value), 참조에 의한 호출(Call by reference)로 구별해 부르기도 하지만 동작방식은 동일하다.

* 함수 몸체에서 매개변수의 값을 변경하는 함수

  ```
  function changeVal(primitive, obj) {
    primitive += 100;
    obj.name = 'Kim';
  }
  
  // 외부 상태
  var num = 100;
  var person = { name: 'Lee' };
  
  console.log(num); // 100
  console.log(person); // {name: "Lee"}
  
  // 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.
  changeVal(num, person);
  
  // 원시 값은 원본이 훼손되지 않는다.
  console.log(num); // 100
  
  // 객체는 원본이 훼손된다.
  console.log(person); // {name: "Kim"}
  ```

* 원시 타입은 값 자체가 복사되어 매개변수에 전달되어서 원본변경이 안된다.
* 객체 타입 인수는 참조값이 복사되어 참조한 객체를 변경하면 원본이 훼손.
* 복잡한 코드에서 객체의 변경은 추적하기 어렵다.
  * 객체를 불변 객체(immutable object)로 만들어 사용하는 방법.
  * 객체를 방어적 복사(defensive copy)해 새로운 객체를 생성후 변경.
* 순수 함수(Pure function): 외부 상태를 변경시키지 않는다.(부수효과 없음)
* 비순수 함수(Impure function): 외부상태 변경한다.(부수효과 있음)
* 비순수 함수를 최대한 줄이자.



#### 반환문

* 함수는 return keyword와 반환문으로 실행 결과를 반환한다.

  ```
  function multiply(x, y) {
    return x * y; // 값의 반환
  }
  
  // 함수는 반환값으로 평가된다.
  var result = multiply(3, 5);
  
  console.log(result); // 15
  ```

* 함수는 return 키워드로 JavaScript에서 사용 가능한 모든값을 반환할 수 있다.
* 반환문은 함수의 실행을 중단하고 몸체를 빠져나간다.
* 반환문은 return키워드 뒤에 지정한 값을 반환한다.(지정하지 않으면 undefined가 반환된다)
* 함수는 반환문을 생략할 수 있다. 모든 문 실행후, 암묵적 undefined 반환.



## 다양한 함수의 형태

#### 즉시 실행 함수(IIFE, Immdediately Invoke Function Expression)

* 함수의 정의와 동시에 즉시 호출되는 함수.

* 한번만 호출되며 다시 호출할 수 없다.

* 함수 이름이 없는 익명 즉시 실행 함수를 사용하는것이 일반적이다.

  ```
  // 익명 즉시 실행 함수
  (function () {
    var a = 3;
    var b = 5;
    return a * b;
  }());
  ```

* 즉시 실행 함수는 그룹 연산자()로 감싸주어야 한다.

* 함수 선언문/표현식을 그룹 연산자로 감싸면 함수가 평가되어 함수 객체된다.

  ```
  console.log(typeof (function f(){})); // function
  console.log(typeof (function (){}));  // function
  ```

* 따라서 그룹 연산자로 먼저 함수를 평가하고, 함수 객체를 생성한 후에 호출.

* 그룹연산자 말고도 함수를 평가하여 함수 객체를 생성하는 방법은 다양하다.

  * 일반적인것:

    ```
    (function () {
      // ...
    }());
    ```

* 즉시 실행 함수는 일반함수처럼 값을 반환할수 있고 인수를 전달할수도 있다.



#### 재귀 함수(recursive function)

* 함수가  자기 자신을 호출하는 것을 재귀 호출(recursive call)이라 한다.
* 재귀 함수는 재귀 호출을 수행하는 함수다.
* 자신을 무한히 연쇄 호출하기때문에 탈출 조건을 만들어야한다.
* 반복문보다 재귀함수 사용이 직관적으로 이해하기 쉬울때만 한정사용.



#### 중첩 함수

* 함수 내부에 정의된 함수를 중첩함수(nested function) 또는 내부 함수(Inner function)라 한다.

* 일반적으로 자신을 포함하는 외부함수를 돕는 헬퍼함수(helper function)의 역할을 한다.

  

#### 콜백 함수(Callback function)

* 자바스크립트 함수는 일급 객체로 함수의 매개변수에게 함수 전달가능하다.

  ```
  // 콜백 함수를 전달받는 함수
  function print(f) {
    var string = 'Hello';
    // 콜백 함수를 전달받는 함수가 콜백 함수의 호출 시기를 결정하고 호출
    return f(string);
  }
  
  // print 함수에 콜백 함수를 전달하면서 호출
  var res1 = print(function (str) {
    return str.toUpperCase();
  });
  
  // print 함수에 콜백 함수를 전달하면서 호출
  var res2 = print(function (str) {
    return str.toLowerCase();
  });
  
  console.log(res1, res2); // HELLO hello
  ```

* print함수는 함수를 인수로 전달받고, print함수에 인수로 전달된 함수는 print함수가 호출할 시기를 결정하여 호출.
  
  * 이때 print함수에 인수로 전달된 함수를 콜백함수라 한다





